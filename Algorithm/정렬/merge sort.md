병합정렬은 배열을 앞부분과 뒷부분으로 나누어 각각을 정렬한 후 병합하는 작업을 반복하는 알고리즘이다.

`[5, 6, 4, 8, 3, 7, 9, 0, 1, 5, 2, 3]`

위와 같은 배열이 있을 때 이를 병합정렬 해보도록 하자. 배열을 두 부분으로 나누는 과정을 계속하며 배열마다 하나의 원소가 남을 때 까지 계속한다.

-> `[5, 6, 4, 8, 3, 7] [9, 0, 1, 5, 2, 3]`

-> `[5, 6, 4] [8, 3, 7] [9, 0, 1] [5, 2, 3]`

-> `[5, 6] [4] [8, 3] [7] [9, 0] [1] [5, 2] [3]`

-> `[5] [6] [4] [8] [3] [7] [9] [0] [1] [5] [2] [3]`

이제 각 배열을 쌍으로 짝지어 정렬하며 병합한다.

-> `[5, 6] [4, 8] [3, 7] [0, 9] [1, 5] [2, 3]`

-> `[4, 5, 6, 8] [0, 3, 7, 9] [1, 2, 3, 5]`

-> `[0, 3, 4, 5, 6, 7, 8, 9] [1, 2, 3, 5]`

-> `[0, 1, 2, 3, 3, 4, 5, 5, 6, 7, 8, 9]`

그렇다면 위와 같이 분할하고 병합하는 과정은 어떻게 구현되는지 살펴보자.

분할의 경우에는 총 배열의 길이에서 정확히 반이 되는 지점을 나누도록 구현하면 된다. 이후 병합하는 과정은 예를 들어 보도록 하자.

`[4, 5, 6, 8] [0, 3, 7, 9]` -> `[0, 3, 4, 5, 6, 7, 8, 9]`

```python
arr1 = [4, 5, 6, 8]
arr2 = [0, 3, 7, 9]
res = []
c_arr1 = 0
c_arr2 = 0

while arr1 or arr2:
    if arr1[c_arr1] <= arr2[c_arr2]:
        res.append[arr1[c_arr1]]
        c_arr1 += 1

    if arr1[c_arr1] > arr2[c_arr2]:
        res.append[arr2[c_arr2]]
        c_arr2 += 1

if arr1:
    for i in range(c_arr1, len(arr1)):
        res.append(arr1[i])

if arr2:
    for i in range(c_arr2, len(arr2)):
        res.append(arr2[i])

return res
```

위와 같이 간단히 코드로 구현해봤다. 각 배열에서 더 작은 값을 결과 배열에 추가하는 방식이다. 그러면 작은 숫자부터 차례대로 결과 배열에 추가된다. 만약 한쪽 배열의 값이 모두 들어갔다면 남은 배열의 값들은 그냥 결과 배열에 추가하면 끝난다.
