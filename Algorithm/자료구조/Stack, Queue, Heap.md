## Stack

**Stack**자료구조는 데이터들이 들어오는 순서대로 쌓이고 마지막에 들어온 데이터부터 나오는 LIFO(Last In First Out)방식의 데이터 구조이다.

스택은 push, pop, peak의 작업을 수행한다. 스택 자료구조 안에 데이터를 추가하는 push, 가장 최근 데이터를 삭제하는 pop, 가장 최근 데이터를 불러오는 peak이다.

어떤 경로 혹은 순서의 기록을 역순으로 저장하고 처리해야 할 때 많이 쓰인다.

- 웹 브라우저 방문기록
- 실행취소 기능 (Ctrl + z)

스택 자료구조의 경우 StackOverflow라는 에러가 발생할 수 있다. 대부분의 경우가 재귀함수의 탈출 코드를 잘못 짰을 때 발생하는데, 재귀함수가 계속해서 자신을 호출하면 메모리의 stack영역에 스택 프레임이 쌓이게 된다. 이게 무한히 지속되면 결국 가용한 모든 공간을 소모하고 StackOverFlow에러가 발생하게 된다.
## Queue

**Queue**자료구조는 데이터들이 들어오는 순서대로 쌓이고 들어온 데이터부터 나오는 FIFO(First In First Out)방식의 데이터 구조이다.

큐는 enqueue, dequeue, peak의 작업을 수행한다. 스택하고 다르게 데이터를 삭제할 때는 가장 오래된 데이터를 삭제하고, 가장 오래된 데이터를 조회한다.

**Deque**는 Queue의 양 끝단에서 데이터의 삽입/삭제가 가능한 자료구조 이다.

Stack과 Queue의 혼합형 자료구조라고 생각할 수 있다.

waiting 시스템 또는 scheduling 등 순서대로 처리가 필요한 경우 많이 쓰인다.

- 식당 예약
- OS 프로세스 스케쥴링
- 최근 방문 사이트 주소(Deque)
- 문서 작성 프로그램의 undo 기록 (Deque)

큐 자료구조의 경우 OutOfMemory에러가 발생할 수 있다. 이는 메모리 영역의 heap영역에 메모리가 가득차서 생기게 되는 에러이다. 해당 에러가 발생하는 이유는 앞단에서 실행 중인 프로세스의 속도가 느리거나 다양한 이유가 있을 수 있다. 에러를 방지하기 위한 방지책으로 큐 자료구조의 크기를 제한하는 방법이 있다. 자료구조의 크기가 무한에 가까울 경우 큐에 데이터가 무제한 쌓여 에러가 발생하기 때문이다. 그러면 큐의 사이즈를 넘어서 계속해서 데이터 삽입 요청이 오면 어떻게 대처해야 할까?

1. 예외 던지기
2. 특별한 값을 반환
3. 성공할 때까지 영원히 블락
4. 제한된 시간에 블락을 하고 시간을 넘으면 포기

첫 번째는 큐가 이미 다 찼다고 예외처리를 하는 방법이다. 두 번째는 첫 번째와 유사한데 예외 에러 처리가 아닌 다른 메세지 등으로 상황을 응답하는 방법이다. 세 번째는 큐에 데이터 삽입이 될 때까지 계속 요청 상태로 대기하는데 이는 스레드 낭비의 문제가 있어 비효율적이다. 마지막 방법은 세 번째와 같이 삽입이 될 때까지 계속 요청을 한 상태로 대기하지만 시간 제한을 두어 제한시간에 오버할 경우 포기하고 예외 처리 및 다른 값을 반환하는 것이다.

## Heap

힙은 이진 트리로 된 자료구조이다. 어떤 기준으로 이진 트리를 구성하는 가에 따라 max heap 또는 min heap이 될 수 있다.

max heap은 가장 큰 값을 헤드 노드에 놓고 이보다 작은 수를 자식 노드에 배치해가면서 마지막 리프 노드부분에는 가장 작은 숫자들이 위치하게 된다. min heap은 이와 반대로 가장 작은 값부터 큰 수로 내림차순으로 헤드 노드부터 리프 노드까지 값이 배정된다.

heap 자료구조의 위와 같은 구조 때문에 heap은 우선순위 큐와 같은 자료구조로 설명되기도 한다. 왜냐하면 힙의 값을 키로 사용하여 데이터를 배치하고 꺼내면 이는 배정된 우선순위대로 재료를 가져와 실행하는 우선순위 큐와 똑같기 때문이다.