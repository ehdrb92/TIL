HashTable은 배열과 해시함수를 사용하여 map과 같이 키, 값형태로 구현된 자료구조이다. 일반적으로 키를 통해 데이터에 접근할 때 상수 시간을 소모하는 빠른 조회속도를 가진다.

해시함수란 임의의 크기를 가지는 타입의 데이터를 고정된 크기를 가지는 타입의 데이터로 변환하는 함수이다. 어떤 특정 값(키)이 해시함수를 거치게 되면 특정한 고정된 상수 값이 나오게 된다. 이 상수값을 해시라고 한다. 그리고 해시를 해시테이블의 capacity 값으로 나누는 모듈러 연산을 수행한다. 그리고 나오는 나머지 값에 해당하는 offset에 키, 값형태로 저장되게 된다.

만약 같은 키가 다른 값으로 생성요청이 들어가게 될 경우 기존에 들어가 있던 키에 대한 값이 수정된다. 다음으로 만약 해시를 모듈러 연산을 해서 나온 offset에 이미 다른 키로된 데이터가 들어가 있다면 어떻게 될까?

이런 경우를 해시 충돌이라고 하는데 두 가지 방식으로 처리할 수 있다.

첫 번째는 Separate Chaining 방식이다. 이미 다른 키가 해당 offset에 자리한다면 먼저 들어와 있던 노드의 next 값으로 연결된 연결 리스트로 만들어 다음 노드로서 구조를 만든다. 그러면 이후 해당 키에 대해 조회를 할 때 해당 해시로 가서 해당 키가 아니면 다음 노드가 있는지 확인하고 다음 노드로 가서 키를 확인한 후 데이터를 가져온다.

두 번째는 Open Adressing 방식이다. 이는 위와 같이 이미 다른 키가 해시를 차지한다면 바로 다음 offset에 해당하는 해시로 이동한다. 만약 비어있다면 모듈러 연산하여 나온 나머지 값과 다르더라도 해당 저장된다. 조회할 때도 해당 해시에 없으면 다음 해시에 찾는 방법으로 진행된다. 그러면 기존에 해시에 있던 데이터가 삭제되면 어떻게 할까? 이때는 삭제된 데이터의 자리에 deleted라는 더미 데이터를 놔둔다. 그러면 조회를 할 때 해당 자리에 데이터가 있었다는 사실을 알고 다음 해시도 탐색하게 된다. 파이썬의 경우 해시 테이블을 다룰 때 이 방식을 사용한다.

마지막으로 해시 테이블 또한 가용한 공간이 다 차지될 경우 확장해야 하면 어떻게 할까? 이를 파이썬 기준으로 설명하면 파이썬의 경우 초기 케파를 8로 정하고 해당 케파의 66% 초과 시 케파를 2 또는 4배로 늘린다고 한다. 이렇게 케파가 늘어나게 되면 기존에 들어가 있던 데이터들도 다시 배치해야한다. 케파가 늘어났기에 해시 함수를 통과하여 나온 상수 값을 새로운 케파 값으로 다시 모듈러 연산하여 해시를 정하고 해당 해시에 따라 저장한다.

그리고 파이썬의 경우 더미 데이터가 유효한 데이터보다 숫자가 많으면 다시 케파를 줄이는 작업을 한다.

마지막으로 해시 테이블의 케파는 항상 2의 제곱 수로 존재한다는 사실을 기억하자.

* 각 원소가 키와 값으로 구성되어 있는 자료 구조이다.
* set와 마찬가지로 특정 순서대로 데이터를 리턴하지 않는다.
* key의 값은 중복될 수 없다.
* 수정 가능하다.

hashtable은 set 자료구조와 유사하여 헷갈릴 수 있는데 차이점은 set는 원소 자체가 해시되어 키의 역할을 하게된다면 hashtable은 키가 해시되어 해시값이 된다.

## 활용

데이터베이스와 같이 키와 값을 묶어서 데이터를 표현해야할 때 유용하다.