#### 컨테이너로 Hello World 실행하기

* docker container run [image_name]

    명령어를 실행하면 도커 어플리케이션 패키지(이미지)를 컨테이너로 실행한다. 만약 로컬에 이미지가 없더면 서버에서 이미지를 내려받은 후 실행한다.

    ```
    ---------------------
    Hello from Chapter 2!
    ---------------------
    My name is:
    0b0e148ddb79
    ---------------------
    Im running on:
    Linux 5.15.49-linuxkit aarch64
    ---------------------
    My address is:
    inet addr:172.17.0.2 Bcast:172.17.255.255 Mask:255.255.0.0
    ---------------------
    ```

    이미지에는 어플리케이션을 실행하는 데 필요한 모든 내용과 함께 어플리케이션을 실행하는 방법이 정의돼 있다. 실행하면 컨테이너가 "Hello from Chapter 2!"라는 문자열을 출력한다. 그리고 그 밑에는 컴퓨터의 이름, 운영체제의 종류, 네트워크 주소가 함께 표기된다.

도커는 특정 사용자가 이미지를 만들고(빌드), 배포하면(공유), 누군가가 이미지를 내려받아 실행한다(실행). 이와같이 "빌드-공유-실행"의 과정이 도커의 핵심이다.

#### 컨테이너란 무엇인가?

특정 어플리케이션들은 동시에 실행하는데 많은 어려움이 따를 수 있다. 필요한 런타임의 버전이 다를 수 있고, 서로 호환되지 않는 버전의 라이브러리를 사용할 수 있다. 이러한 상황을 해결하기 위해서는 격리와 밀집 두 가지 조건을 만족하는 별개의 환경을 필요로 했다.

가상 머신은 하이퍼바이저 위에서 각각의 독립된 환경을 구축할 수 있다. 하지만 각각의 가상 머신은 자신만의 운영체제를 갖는다. 이 운영체제는 어플리케이션이 사용해야할 CPU와 메모리 자원을 상당량 차지한다. 이외에도 운영체제의 라이선스 비용과 운영체제 업데이트 설치 부담이 추가로 생긴다. 결국 가상 머신은 격리는 달성할 수 있었지만 밀집의 조건을 달성하지 못했다.

컨테이너의 경우 이러한 단점을 해결할 수 있다. 각각의 컨테이너는 호스트 컴퓨터의 운영체제를 공유하며 필요한 리소스를 크게 경감 시킨다. 그만큼 실행이 빠르고 같은 호스트 컴퓨터 안에서 가상 머신에 비해 많은 수의 어플리케이션을 실행할 수 있다. 그래서 격리와 밀집 두 가지 조건을 동시에 만족시킬 수 있다.

#### 컨테이너를 원격 컴퓨터처럼 사용하기

컨테이너는 간단한 메세지를 출력해주는 일 이외에도 많은 일을 할 수 있다. 컨테이너를 실행하고 그 안에서 마치 원격 컴퓨터에 접속하듯 터미널을 사용할 수 있다.

* docker container run --interactive --tty [image_name]

    --interactive 플래그를 사용하면 컨테이너에 접속된 상태가 된다. 그리고 --tty 플래그는 터미널 세션을 통해 컨테이너를 조작하겠다는 의미이다. 컨테이너 내부에서 명령 프롬프트를 통해 조작을 할 수 있게 된다.

    / # hostname
    3552e3c522e7
    / # date
    Tue Nov  8 14:28:31 UTC 2022

    hostname은 컨테이너 ID이다. 도커는 컨테이너를 실행할 때마다 임의의 컨테이너 ID를 부여한다. 그리고 이 ID 값 중 일부가 호스트명이 된다. 특정한 컨테이너에 대해 실행할 수 있는 다양한 명령어가 있는데, 이때 컨테이너를 특정하려고 하면 ID의 처음 몇 글자를 지정하면 된다.

* docker container ls

    명령을 실행하면 현재 실행 중인 모든 컨테이너에 대한 정보를 볼 수 있다.

    CONTAINER ID   IMAGE         COMMAND     CREATED         STATUS         PORTS     NAMES
    3552e3c522e7   diamol/base   "/bin/sh"   2 minutes ago   Up 2 minutes             gifted_kirch

* docker container top [container_id]

    컨테이너에서 실행 중인 모든 프로세스에 대한 정보가 출력된다.

    UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
    root                2160                2135                0                   14:28               ?                   00:00:00            /bin/sh

* docker container logs [container_id]

    대상 컨테이너에서 수집된 모든 로그를 출력한다.

* docker container inspect [container_id]

    대상 컨테이너의 상세정보를 출력한다. 컨테이너의 가상 파일 시스템상의 경로, 실행 중인 명령, 접속된 가상 도커 네트워크 정보 등 어플리케이션에서 발생한 문제를 추적하는데 유용한 정보들이 제공된다.

#### 컨테이너를 사용해 웹 사이트 호스팅하기

* docker container ls --all

    상태와 상관없이 모든 컨테이너의 목록을 확인할 수 있다.

    CONTAINER ID   IMAGE                      COMMAND                 CREATED          STATUS                      PORTS     NAMES
    3552e3c522e7   diamol/base                "/bin/sh"               15 minutes ago   Exited (0) 14 seconds ago             gifted_kirch
    0b0e148ddb79   diamol/ch02-hello-diamol   "/bin/sh -c ./cmd.sh"   30 minutes ago   Exited (0) 30 minutes ago             naughty_sammet
    2129ac0b963c   diamol/ch02-hello-diamol   "/bin/sh -c ./cmd.sh"   35 minutes ago   Exited (0) 35 minutes ago             infallible_elgamal

    컨테이너 내부의 어플리케이션이 실행 중이어야 상태가 실행 중이 된다. 어플리케이션이 종료되면 상태도 Exited가 된다. 종료된 컨테이너는 CPU 자원이나 메모리를 사용하지 않는다.

    컨테이너는 종료되어도 사라지지 않는다. 나중에 컨테이너를 다시 실행하거나, 로그를 확인하거나, 컨테이너의 파일 시스템에 새로운 파일을 복사하거나 외부로 복사해 올 수 있다. 또한 컨테이너의 파일 시스템이 그대로 남아있어 호스트 컴퓨터의 디스크 공간을 계속 점유한다.

* docker container run --detach --publish 8088:80 [image_name]

    docker container run --detach --publish 8088:80 diamol/ch02-hello-diamol-web
    560cfbdf954077dcfcb20d56e1a6e9ecb9176df9a31c52a2a45479b402de8c04

    CONTAINER ID   IMAGE                          COMMAND              CREATED         STATUS         PORTS                  NAMES
    560cfbdf9540   diamol/ch02-hello-diamol-web   "httpd-foreground"   5 minutes ago   Up 5 minutes   0.0.0.0:8088->80/tcp   fervent_brattain

    컨테이너가 백그라운드에서 동작하게 하면서 네트워크를 주시하게 하려면 두 개의 플래그를 붙여야 한다.

    + --detach: 컨테이너를 백그라운드에서 실행하며 컨테이너 ID를 출력한다.
    + --publish: 컨테이너의 포트를 호스트 컴퓨터에 공개한다.

    --detach 플래그를 이용해 실행된 컨테이너는 마치 리눅스 데몬이나 윈도 서비스처럼 백그라운드로 동작하며 겉으로 드러나지 않는다. 컨테이너의 포트를 호스트 컴퓨터에 공개하는 원리는 복잡하다. 도커를 설치하면 호스트 컴퓨터의 네트워크 계층에 도커가 끼어들게 된다. 그러면 호스트 컴퓨터에서 들고나는 네트워크 트래픽을 모두 도커가 가로채서 그 중 필요한 것을 컨테이너에 전달한다.

    각 컨테이너는 고유의 IP 주소를 갖지만, 이는 도커가 관리하는 내부 가상 네트워크 주소이다. 컨테이너의 포트를 공개한다는 것은 도커가 호스트 컴퓨터의 포트를 주시하다가 해당 포트로 들어오는 트래픽을 컨테이너에 전달해주는 것이다. 위의 예제는 호스트 컴퓨터의 8080번 포트로 들어온 트래픽이 컨테이너 80번 포트로 전달된 것이다.

* docker container stats [container_id]

    실행 중인 컨테이너의 상태를 확인할 수 있다. 컨테이너의 CPU, 메모리, 디스크 사용량을 확인할 수 있다.

* docker container rm --force $(docker container ls --all --quiet)

    모든 컨테이너를 삭제하는 명령이다.

#### 도커가 컨테이너를 실행하는 원리

도커는 다음과 같은 컴포넌트로 구성되어 있다.

* 도커 엔진: 도커의 관리 기능을 맡는다. 로컬 이미지의 캐시를 담당하여 새로운 이미지가 필요하면 내려받고, 기존 이미지가 있다면 전에 내려받은 이미지를 사용한다. 호스트 운영체제와 함께 컨테이너와 가상 네트워크 등 도커 리소스를 만드는 일도 담당한다. 도커 엔진은 항시 동작하는 백그라운드 프로세스다.
* 도커 API: 표준 HTTP 기반 REST API다. 도커 엔진과 상호작용하기 위해 요청을 받는다.
* 도커 명령행 인터페이스(CLI): 도커 API의 클라이언트다. 우리가 도커 명령을 사용할 때 실제로 도커 API를 호출하는 것이 도커 CLI이다.

도커 API는 명세가 공개되어 있다. 그러므로 도커 CLI 외의 다른 클라이언트를 사용할 수 있다.